# Express Node Framework

### Objective: -

In this module we'll look at ...

- Building a better server solution with Express
- Routing with the `route()` method
- Adding `request.params` to routes
- Adding Response methods
- Middleware functions for Request-logging and Body-Parsing
- Separating routes with the Router Object
- Passing dynamic Environment Variables

<br>

---

<br>

## A better Server Solution

In the last lesson, we built a RESTful API to handle the management of blog posts.

While that API _works_, it doesn't work very _well_. Those rough edges include:

- parsing request bodies
- handling internal errors as proper status codes
- awkward routing and handler organization
- difficult path-parsing and validation
- difficulty handling common operations for requests and responses grouped by path and method

All of these shortcomings are problems that every user of the `http` module needs to solve.

Being programmers, we know that it's probably not a good idea to reinvent the wheel once we understand why the wheel exists and how it rolls. Instead, we'd reach for a collection of tools that provide helpers and handlers that reduce our own flexibility a little bit by making reasonable decisions for us about how to handle some of those rough edges across applications.

One such toolkit for writing HTTP ReSTful APIs is a package called [`express`](https://expressjs.com/).

We can install `express` with:

```bash
npm install express
```

> `express` is very common, but it's not the only framework in town! Some other Node.js frameworks that you might see would be [`koa`](https://koajs.com/), [`hapi`](https://hapi.dev/), [`sails`](https://sailsjs.com/), or [`meteor`](https://www.meteor.com/) (among others).

And if you like the way that `express` works, you can find similar frameworks in most programming languages. See [`flask`](https://flask.palletsprojects.com/en/1.1.x/) for Python, [`sinatra`](http://sinatrarb.com/) for Ruby, or [`slim`](http://www.slimframework.com/) for PHP.

<br>

---

<br>

## Building an Express Server

To get started, let's compare the simplest possible `http` server with the simplest possible `express` application. For review, here's the `http` version:

```javascript
const http = require("http");
const server = http.createServer(() => {});

if (request.url === "/status" && request.method === "GET") {
  response.writeHead(200, { "Content-Type": "application/json" });
  response.write(JSON.stringify({ message: "Service healthy" }));
  response.end();
}

server.listen(4040);
console.log("Listening on port 4040");
```

<br>

and here's the equivalent `express` application:

```javascript
const express = require("express");
const app = express();

server.get("/status", (request, response) => {
  response.send(JSON.stringify({ message: "Service healthy" }));
});

app.listen(4040, () => console.log("Listening on port 4040"));
```

As you can see, they look pretty similar. The biggest difference so far is the absence of a request listener callback in the `app` constructor function.

<br>

---

<br>

## Routing with the `route()` method

Instead of forcing you to use a single top-level request-handler, `express` uses a [`Router` Object](https://expressjs.com/en/4x/api.html#router) (included in the `app` instance through the `route()` method) to make it easier to break up your handlers by both _path_ and _method_.

A single route for `/users` in `express` would look like this:

```javascript
app
  .route("/users")
  .get((request, response) => {
    // handle GET request
  })
  .post((request, response) => {});
```

<br>

---

<br>

### Activity 1: Create a Basic Express Server

Let's create a basic express server that handles a GET request on the home route( `/` ):

1. In our practice SPA's `server` folder, rename the `index.js` file to `handlersHTTPServer.js` and create a new `index.js`
2. Add the boilerplate for an `express` server:
   ```javascript
   const express = require("express");
   const app = express();
   app.listen(4040, () => console.log("Listening on port 4040"));
   ```
3. Chain the `route()` and `get()` methods onto the app to respond to a GET request on the home route:
   ```js
   app.route("/").get((request, response) => {
     response.send("HELLO WORLD");
   });
   ```

<br>

---

<br>

## Adding `request.params`

An important property of the posts route above: it _only_ applies to `/posts`. So `/posts/some-post-id` would _not_ match the above routes.

To match routes that contain a parameter that might be different for every request, `express` has built-in parsing of named _parameters_ from a path with the following syntax:

```javascript
app.route("/posts/:id").get((request, response) => {
  // express adds a "params" Object to requests
  const id = request.params.id;
  // handle GET request for post with an id of "id"
});
```

We'll come back to this concept after examining _`response` methods_ and _middleware_.

<br>

---

<br>

## `response` Methods

You'll notice that every helper function that we've created does three things over and over again:

1. sets a status code for the response
2. stringifies and writes JSON payloads to the response body
3. terminates the response with `end()`

There are also some things that our helpers _don't_ do, but really should, like setting a `Content-Length` header based on the length of the response.

This is not required, but it's a pretty good idea to give clients a hint about the size of the payload that you're sending back to them. And while we could manually add that header, `express` adds some helper methods to each `response` Object that provides most of those same defaults out-of-the-box, as well as doing all three of the things listed above that our helpers already do.

For our JSON API, the most important of these methods will be `response.json()` and `response.status()`.

In addition, these helper methods return a new `response` Object, making them _chainable_. So our entire `notFound` helper can now be re-written as `response.status(404).json({ message: 'Not Found' })`.

We can replace all of our helpers with `status` and `json` method chains and get rid of those functions entirely!

<br>

---

<br>

### Activity 2: Adding `response` Methods

Let's alter our response to a GET request on the home route to use the `status` and `json` methods

```js
app.route("/").get((request, response) => {
  response.status(200).json({ message: "HELLO WORLD" });
});
```

> **NOTE**: By default, the response status is 200, so the `status` method is unnecessary in this example.

<br>

---

<br>

## Middleware functions

`express` is built around the idea of [middleware](https://expressjs.com/en/guide/using-middleware.html). Middleware are functions that have access to the request and response Objects of their respective scopes.

You can have `app`-level middleware, `router`-level middleware, or `route`-level middleware for any request or response logic that might need to be shared among handlers on those routes.

You can think of every request passing through every middleware function on the way to a handler, and every response passing through every middleware function again on the way to the user. This design makes it very easy to implement app-level features like auth, request body parsing, caching, and database connection pooling.

A middleware function in `express` will have the following form:

```javascript
const myMiddleware = (request, response, next) => {
  // do something with request and/or response
  next(); // tell express to move to the next middleware function
};

app.use(myMiddleware); // use the myMiddleware for every request to the app
```

<br>

---

<br>

### Activity 3: Request-logging -- Middleware & `morgan`

1. In your `server/index.js`, let's create a middleware function that will log the method, url, and time of every request:

   ```javascript
   const logging = (request, response, next) => {
     console.log(`${request.method} ${request.url} ${Date.now()}`);
     next();
   };
   ```

2. In your `app`, use that `logging` middleware **before** any of your route configurations, like so:

   ```javascript
   app.use(logging);
   ```

3. Now make a few requests to your API with `curl` to verify that your request-logging-middleware is working as expected.

4. As you might expect, logging requests and responses is a common requirement for APIs. As such, there are already a number of logging middleware packages built for `express` with more features than our simple function. Let's use the most popular of these packages, [`morgan`](https://github.com/expressjs/morgan). After installing `morgan`, you can replace our `app.use` with `morgan`'s logger:

   ```bash
   npm install morgan
   ```

   ```javascript
   const morgan = require("morgan"); // with the rest of your imports

   app.use(morgan("dev")); // where we previously used 'logging'
   ```

5. Make a few more requests to your API. Notice how `morgan` gives us fancier colors and status codes for every request/response cycle, including the amount of time it took for the entire cycle to complete. This is a great tool for debugging and monitoring your APIs during development and while deployed to production!

<br>

---

<br>

### Activity 4: Body-Parsing -- Middleware & `body-parser`

Let's use the [`json` middleware of the `body-parser` npm package](https://www.npmjs.com/package/body-parser#bodyparserjsonoptions) to handle _JSON_ requests as well as responses.

1. Install the `body-parser` package with `npm install body-parser`

2. In your server, `require` and `use` the `json` body parser like so:

   ```javascript
   const bodyParser = require("body-parser"); // with the rest of your imports

   app.use(bodyParer.json());
   app.use(morgan("dev"));

   /*
     express supports chaining `use()` statements,
     so the above 2 statements could look like this as well
     app.use(bodyParser.json()).use(morgan('dev'))
   */
   ```

3. `body-parser` works by checking the `Content-Type` header of a request and parsing the body accordingly. Up to this point, we've been sending plain ol' text through `curl` (technically interpreted as `application/x-www-form-urlencoded`). But if we want our request bodies to be properly parsed automatically, we need to tell our server when we make our request! A `POST` request with a JSON-formatting looks like this:

   ```bash
   curl -X POST -H 'Content-Type: application/json' -d '{"body": "This is another new post"}' localhost:4040
   ```

   Notice the new JSON format of our request body, and notice the `-H` option letting our server know that we're working with JSON in the request.

4. **Before** actually using that `curl` request, we'll want to make sure that we can handle that JSON body in our application. Thankfully, you'll find that this is much more intuitive than the previous `readableStream` aka `chunk` implementation. Let's add a `post` method handler onto our home route that echoes back a request with a JSON body:

   ```js
   app
     .route("/")
     .get((request, response) => {
       response.json({ message: "HELLO WORLD" });
     })
     .post((request, response) => {
       response.json(request.body);
     });
   ```

<br>

---

<br>

## Separate Routers with the Router Object

Instead of specifying routes on the `app` (which is a single, global routing Object), we should use the `express.Router` Object to organize the `/users` routes as middleware for our global `app`.

<br>

---

<br>

### Activity 5: Adding a `/posts` Route

1. First, let's create a new `server/routers` subdirectory to hold all of our routers. Inside of that directory, create a `server/routers/users.js` file.

2. In `users.js`, let's `require` the `Router` from `express`, construct a new one in the `users` file, then refactor all of the `users` routing from our `http` server.

```javascript
const { Router } = require("express");
const router = Router();

router
  // routes will be specified at the app-level
  .route("/") // equivalent to /users
  .get((request, response) => {
    const users = db.get("users").value();
    response.json(users);
  })
  .post((request, response) => {
    const user = db
      .get("users")
      .insert(request.body)
      .write();
    response.json(user);
  });
// don't forget to export the router Object
module.exports = router;
```

3. Still in `users.js`, lets handle the `/users/:id` route by adding a new route to our `router` and refactoring our code from our `GET`, `PATCH`, and `DELETE` handlers used in our `http` server:

```js
// route.route("/")...

router
  .route("/:id") // equivalent to /users/:id
  .get((request, response) => {
    // use params Object to get the ID
    const id = request.params.id;
    const user = db
      .get("users")
      .getById(id)
      .value();

    if (user) {
      response.json(user);
    } else {
      response.status(404).json({ message: "Not Found" });
    }
  })
  .patch((request, response) => {
    const id = request.params.id;
    const user = db
      .get("users")
      .updateById(id, request.body)
      .write();

    if (user) {
      response.json(user);
    } else {
      response.status(404).json({ message: "Not Found" });
    }
  })
  .delete((request, response) => {
    const id = request.params.id;
    const user = db
      .get("users")
      .removeById(id)
      .write();

    if (user) {
      response.json(user);
    } else {
      response.status(404).json({ message: "Not Found" });
    }
  });

// router export statement
```

4. Once the router for posts has been built, import and `use` that router in `server/index.js`:

```javascript
const users = require("./routers/users");

// notice how our users router is middleware itself!
// we use our "users" router Object on the specified route - "/users"
app
  .use(bodyParser.json())
  .use(morgan("dev"))
  .use("/users", users);
```

5. Now we can repeat the exact same process for pizzas! See if you can create and include an `pizzas` router that exposes the exact same routes as `/users`

6. If done correctly, you should now be able to `curl -X POST -H 'Content-Type: application/json'` data from `users` in our db. Try creating a few posts with the schema outlined above in JSON format!

<br>

---

<br>

## Passing Environment Variables

So far, we've been hard-coding the `PORT` in our application. But in the next lesson, we will need to be able to change the `PORT` of our `express` app by environment. In this case, our "production" deployment will have a different port than the one that we've hard-coded.

Node provides a way of reading variables from the environment called `process.env`. `process` refers to the Node process itself, and `env` is an Object with all of the variables accessible to the Node process from the environment. When running a `node` script, you can pass environment variables to the `node` process with the following syntax (in this example, setting a `PORT` variable):

```bash
PORT=8080 node ./server/index.js
```

Let's make our PORT configurable by changing our `const PORT` declaration to the following:

```javascript
const PORT = process.env.PORT || 4040; // we use || to provide a default value
```

<br>

---

<br>

### Summary: -

In this module we looked at ...

- Building a better server solution with Express
- Routing with the `route()` method and adding `request.params` to routes
- Adding Response methods
- Adding Middleware for Request-logging and Body-Parsing
- Separating CRUD operation routes with the Router Object
- Passing dynamic Environment Variables (like the port number) with `process.env`
